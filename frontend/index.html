<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Anomaly Detection Dashboard</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f5f5; }
        .dashboard { padding: 20px; max-width: 1400px; margin: 0 auto; }
        .header { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .btn { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn:hover { opacity: 0.9; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .metric { text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px; }
        .metric-value { font-size: 24px; font-weight: bold; color: #007bff; }
        .metric-label { font-size: 12px; color: #666; margin-top: 5px; }
        .status { display: inline-block; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; }
        .status-running { background: #d4edda; color: #155724; }
        .status-stopped { background: #f8d7da; color: #721c24; }
        .log-stream { height: 300px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; }
        .log-entry { margin-bottom: 5px; padding: 5px; border-radius: 3px; }
        .log-normal { background: #e8f5e8; }
        .log-anomaly { background: #ffe6e6; font-weight: bold; }
        .chart-container { position: relative; height: 300px; }
        .loading { text-align: center; padding: 20px; color: #666; }
        @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const API_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:8001' 
            : 'https://YOUR_BACKEND_URL.onrender.com';
        
        const WS_URL = window.location.hostname === 'localhost'
            ? 'ws://localhost:8001/ws'
            : 'wss://YOUR_BACKEND_URL.onrender.com/ws';

        function Dashboard() {
            const [status, setStatus] = useState({});
            const [metrics, setMetrics] = useState({});
            const [models, setModels] = useState({});
            const [logs, setLogs] = useState([]);
            const [isTraining, setIsTraining] = useState(false);
            const [latencyData, setLatencyData] = useState([]);
            const [anomalyData, setAnomalyData] = useState([]);
            
            const wsRef = useRef(null);
            const latencyChartRef = useRef(null);
            const anomalyChartRef = useRef(null);
            const latencyChartInstance = useRef(null);
            const anomalyChartInstance = useRef(null);

            useEffect(() => {
                connectWebSocket();
                fetchStatus();
                fetchModels();
                fetchMetrics();
                
                const interval = setInterval(() => {
                    fetchStatus();
                    fetchMetrics();
                }, 5000);
                
                return () => {
                    clearInterval(interval);
                    if (wsRef.current) wsRef.current.close();
                };
            }, []);

            useEffect(() => {
                if (latencyChartRef.current && !latencyChartInstance.current) {
                    latencyChartInstance.current = new Chart(latencyChartRef.current, {
                        type: 'line',
                        data: { labels: [], datasets: [{ label: 'Latency (ms)', data: [], borderColor: '#007bff', backgroundColor: 'rgba(0, 123, 255, 0.1)', tension: 0.4 }] },
                        options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                    });
                }
                if (anomalyChartRef.current && !anomalyChartInstance.current) {
                    anomalyChartInstance.current = new Chart(anomalyChartRef.current, {
                        type: 'line',
                        data: { labels: [], datasets: [{ label: 'Anomaly Score', data: [], borderColor: '#dc3545', backgroundColor: 'rgba(220, 53, 69, 0.1)', tension: 0.4 }] },
                        options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                    });
                }
            }, []);

            const connectWebSocket = () => {
                const ws = new WebSocket(WS_URL);
                ws.onopen = () => { console.log('WebSocket connected'); wsRef.current = ws; };
                ws.onmessage = (event) => handleRealtimeData(JSON.parse(event.data));
                ws.onclose = () => { console.log('WebSocket disconnected'); setTimeout(connectWebSocket, 3000); };
            };

            const handleRealtimeData = (data) => {
                setLogs(prev => [...prev, data].slice(-50));
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                
                setLatencyData(prev => {
                    const newData = [...prev, { timestamp, value: data.log.latency_ms }].slice(-20);
                    if (latencyChartInstance.current) {
                        latencyChartInstance.current.data.labels = newData.map(d => d.timestamp);
                        latencyChartInstance.current.data.datasets[0].data = newData.map(d => d.value);
                        latencyChartInstance.current.update('none');
                    }
                    return newData;
                });

                setAnomalyData(prev => {
                    const newData = [...prev, { timestamp, value: data.prediction.anomaly_score }].slice(-20);
                    if (anomalyChartInstance.current) {
                        anomalyChartInstance.current.data.labels = newData.map(d => d.timestamp);
                        anomalyChartInstance.current.data.datasets[0].data = newData.map(d => d.value);
                        anomalyChartInstance.current.update('none');
                    }
                    return newData;
                });
            };

            const fetchStatus = async () => {
                try {
                    const response = await fetch(`${API_URL}/status`);
                    setStatus(await response.json());
                } catch (error) { console.error('Failed to fetch status:', error); }
            };

            const fetchModels = async () => {
                try {
                    const response = await fetch(`${API_URL}/models`);
                    setModels(await response.json());
                } catch (error) { console.error('Failed to fetch models:', error); }
            };

            const fetchMetrics = async () => {
                try {
                    const response = await fetch(`${API_URL}/metrics`);
                    setMetrics(await response.json());
                } catch (error) { console.error('Failed to fetch metrics:', error); }
            };

            const handleTrain = async () => {
                setIsTraining(true);
                try {
                    await fetch(`${API_URL}/train`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ duration_seconds: 60 })
                    });
                    fetchModels();
                } catch (error) { console.error('Training failed:', error); }
                finally { setIsTraining(false); }
            };

            const handleStart = async () => {
                try {
                    await fetch(`${API_URL}/start`, { method: 'POST' });
                    fetchStatus();
                } catch (error) { console.error('Failed to start:', error); }
            };

            const handleStop = async () => {
                try {
                    await fetch(`${API_URL}/stop`, { method: 'POST' });
                    fetchStatus();
                } catch (error) { console.error('Failed to stop:', error); }
            };

            const handleModelChange = async (modelName) => {
                try {
                    await fetch(`${API_URL}/model`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ model_name: modelName })
                    });
                    fetchStatus();
                } catch (error) { console.error('Failed to change model:', error); }
            };

            return (
                <div className="dashboard">
                    <div className="header">
                        <h1>Network Anomaly Detection Dashboard</h1>
                        <div className="controls">
                            <button className="btn btn-primary" onClick={handleTrain} disabled={isTraining || status.is_running}>
                                {isTraining ? 'Training...' : 'Train Models'}
                            </button>
                            <button className="btn btn-success" onClick={handleStart} disabled={status.is_running || status.training_data_size < 50}>
                                Start Detection
                            </button>
                            <button className="btn btn-danger" onClick={handleStop} disabled={!status.is_running}>
                                Stop Detection
                            </button>
                            <select className="select" value={status.current_model || ''} onChange={(e) => handleModelChange(e.target.value)} disabled={status.is_running}>
                                {Object.entries(models.models || {}).map(([key, model]) => (
                                    <option key={key} value={key} disabled={!model.trained}>
                                        {model.name} {!model.trained ? '(Not Trained)' : ''}
                                    </option>
                                ))}
                            </select>
                            <span className={`status ${status.is_running ? 'status-running' : 'status-stopped'}`}>
                                {status.is_running ? 'RUNNING' : 'STOPPED'}
                            </span>
                        </div>
                    </div>

                    <div className="grid">
                        <div className="card">
                            <h3>System Metrics</h3>
                            <div className="metrics">
                                <div className="metric">
                                    <div className="metric-value">{metrics.total_logs_processed || 0}</div>
                                    <div className="metric-label">Total Logs</div>
                                </div>
                                <div className="metric">
                                    <div className="metric-value">{metrics.total_anomalies_detected || 0}</div>
                                    <div className="metric-label">Anomalies Detected</div>
                                </div>
                                <div className="metric">
                                    <div className="metric-value">{((metrics.current_anomaly_rate || 0) * 100).toFixed(1)}%</div>
                                    <div className="metric-label">Anomaly Rate</div>
                                </div>
                                <div className="metric">
                                    <div className="metric-value">{(metrics.precision || 0).toFixed(2)}</div>
                                    <div className="metric-label">Precision</div>
                                </div>
                                <div className="metric">
                                    <div className="metric-value">{(metrics.recall || 0).toFixed(2)}</div>
                                    <div className="metric-label">Recall</div>
                                </div>
                                <div className="metric">
                                    <div className="metric-value">{(metrics.avg_detection_latency_ms || 0).toFixed(1)}ms</div>
                                    <div className="metric-label">Avg Latency</div>
                                </div>
                            </div>
                        </div>

                        <div className="card">
                            <h3>Live Log Stream</h3>
                            <div className="log-stream">
                                {logs.length === 0 ? (
                                    <div className="loading">No logs yet. Start detection to see live data.</div>
                                ) : (
                                    logs.slice(-20).map((log, index) => (
                                        <div key={index} className={`log-entry ${log.prediction.is_anomaly ? 'log-anomaly' : 'log-normal'}`}>
                                            [{new Date(log.timestamp).toLocaleTimeString()}] 
                                            {log.prediction.is_anomaly ? ' ðŸš¨ ANOMALY' : ' âœ“ Normal'} - 
                                            Latency: {log.log.latency_ms.toFixed(1)}ms, 
                                            Score: {log.prediction.anomaly_score.toFixed(3)}
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="grid">
                        <div className="card">
                            <h3>Network Latency</h3>
                            <div className="chart-container">
                                <canvas ref={latencyChartRef}></canvas>
                            </div>
                        </div>
                        <div className="card">
                            <h3>Anomaly Scores</h3>
                            <div className="chart-container">
                                <canvas ref={anomalyChartRef}></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<Dashboard />, document.getElementById('root'));
    </script>
</body>
</html>
